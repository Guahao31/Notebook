# Operating Systems: Three Easy Pieces

[Free Web version](https://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters) By Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, [code in repo](https://github.com/remzi-arpacidusseau/ostep-code).

> 本书从虚拟化、并发以及持久化这三个主题展开，介绍了绝大多数操作系统中的重要概念。

## CH02 引言

OS 负责什么？OS 作为软件保证**正确、高效地运行应用程序**，管理各种程序使用共享内存，管理程序与外设间的通信等。

### 虚拟化

虚拟化 CPU：在单核 CPU 上虚拟多道程序运行。OS 需要一些协议来保证程序的运行顺序，资源管理等。

虚拟化内存：主要问题是虚拟地址到物理地址的映射。每段程序有自己的一段虚拟地址空间，对于不同的程序，即使虚拟地址相同，也不意味着映射到同一物理地址上。

### 并发

当一个程序需要同时处理多个任务时，会产生**并发**。实际上 OS 本身就需要处理并发的问题。

### 持久化

内存设备如 DRAM 等通常是易失性的，断电后内部数据都会丢失，因此需要其他硬件来**持久地**保存一部分数据，即对一些数据进行持久化。

与 CPU 和内存不同，OS 并不会提供虚拟化的磁盘设备，因为通常情况下用户会想通过这些持久化的文件共享信息，而不是虚拟化后独自使用。

### 设计目标

需要构建一些功能的**抽象**来更简单地使用 OS 与设备。

希望能够设计实现**高性能**的 OS。希望尽可能地降低 OS 提供的如虚拟化的功能所带来的额外开销。

需要提供不同应用程序间的**隔离**（包括 OS 与应用程序之间）。

OS 需要更**可靠**，因为一旦 OS 崩溃，在其上运行的所有应用程序都会崩溃。

OS 还需要节能、保证安全性、可移动性等。

### 一些历史

一开始 OS 并不会负责很多功能，只提供一些最简单的库，如简单的 IO 接口，这时的 OS 通常只能运行一个程序，有专**人**负责对不同程序进行调度。这样的程序被称为**批处理**程序。

之后，人们认为应当区别看待 OS 与其他应用程序，因为 OS 通常能够接触到所有的设备等资源。这是什么 **system call** 的概念被引入，其他应用程序需要通过 system call 像 OS 请求处理，再由 OS 判断是否处理并执行、返回结果。

随着发展，OS 开始能够支持**多道程序**，可以将多个任务提到内存并在不同任务间进行切换，来实现看上去有多个程序在运行，提高了 CPU 的利用率。

个人计算机出现，逐渐形成了现代的、复杂的、高效处理程序运行的操作系统。

## CH04 The Abstraction: The Process

**进程**即一个*运行中*的程序。所谓的程序指的是位于硬盘的持久化的文件，它由一系列的指令以及一些静态数据组成。OS 通过虚拟化 CPU 实现多道程序，*运行一个程序-暂停-运行另一个程序...*，这样的过程保证了不同进程仿佛拥有一个专门的 CPU 一样。*CPU 的时间共享*是实现多道程序的基本方式，代价是程序运行的性能可能会受到影响。

machine state 即一个程序在运行过程中可以读和更新什么内容。machine state 包含程序管理的内存（指令与数据）或称地址空间；寄存器，包括通用寄存器和 PC SP FP 等专用寄存器；持久性存储设备等，也包括一个记录了程序打开的文件的列表。

### Process API

- **Create**：开启新的进程
- **Destroy**：强制关闭进程
- **Wait**：等待一个进程结束
- **Miscellaneous Control**：除了强制关闭和等待进程结束外，还有一些可能需要的控制行为，比如挂起程序（暂停某程序的运行）以及恢复程序运行
- **Status**：获取状态信息，如进程运行时间或正处于什么状态

### Process Creation

在 OS 创建进程时，需要现将代码与静态数据从硬盘等持久性存储设备中载入到内存中这一进程的地址空间内。在早期的操作系统中，载入程序是在运行之前完成的；而现代操作系统通常是“懒惰地”载入，即需要哪段代码或数据，才将这部分内容载入到内存中，这部分内容需要到分页以及交换时才能详细了解。

当程序完成载入后，OS 还需要为栈和堆申请内存空间，同时需要进行一些初始化操作。

- `fork()`：为本进程生成一份“拷贝”子进程，根据其返回值可以判断是父进程（返回值为子进程的 pid）还是子进程（返回值为 0）
- `wait()`：等待子进程结束并返回
- `exec()`：执行不同于当前进程正在运行程序的新程序，会结束当前进程的运行，载入新的代码与静态数据段等并进行初始化

### 有限直接执行(Limited Direct Execution)

从安全性考虑，有一些指令是不可以被用户直接执行的（比如申请更多的内存空间、访问 I/O 等），可以通过划分特权级来解决这个问题。一个普通的程序会运行在**用户态**，在这种状态下，只能运行有限的指令，当有特别需要时，通过系统调用(system call)转到**内核态**完成用户态下无法完成的任务。用户通过 trap 进行系统调用，需要将请求类型写到特定位置（比如某个寄存器或栈上特定位置），内核态需要判断这个请求能否完成，在完成后恢复运行状态并返回用户态（return-from-trap）的代码继续运行。在系统启动时会在内核态设置一张 trap table，用来表示每一种不同的 trap 处理程序的位置。

对于单核系统，在用户程序运行时内核一定是不在运行的，内核如何重新运行起来？对于一个用户程序，它可以通过在合理的位置进行系统调用将 CPU “归还”给内核，但是如果一个用户程序陷入死循环或者恶意地不进行系统调用而影响整个操作系统，此时只能通过重启系统解决，因此这不是一个合理的解决方案。实际上通过**“时钟中断”**，有一个硬件时钟每隔一段时间就进行一次时钟中断，以此回到内核运行的状态来进行进程调度。在系统启动时也需要使用特权指令开启一个时钟，且有时在内核态下需要关闭这个时钟来处理一些任务，需要注意的是对时钟的开关时需要内核态处理的，用户态无法直接接触。

进行进程切换时，内核需要负责进行上下文切换，比如将需要保存的寄存器值保存在指定位置，并将将要运行的进程原本的寄存器值进行恢复。

#90